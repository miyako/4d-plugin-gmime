/* --------------------------------------------------------------------------------
 #
 #  4DPlugin-MIME.cpp
 #	source generated by 4D Plugin Wizard
 #	Project : MIME
 #	author : miyako
 #	2021/04/01
 #  
 # --------------------------------------------------------------------------------*/

#include "4DPlugin-MIME.h"

static bool getHeaders(GMimeObject *part, const char *label, Json::Value& json_message) {
    
    bool hasHeaders = false;
    
    GMimeHeaderList *headers = g_mime_object_get_header_list (part);
    
    if(headers)
    {
        int len = g_mime_header_list_get_count(headers);
        
        if(len)
        {
            hasHeaders = true;
            
            Json::Value header_array = Json::Value(Json::arrayValue);
                        
            for(int i = 0; i < len; ++i)
            {
                GMimeHeader *h = g_mime_header_list_get_header_at(headers, i);
                
                Json::Value item = Json::Value(Json::objectValue);
                            
                item["name"]  = g_mime_header_get_name(h);
                item["value"] = g_mime_utils_header_decode_text(NULL, g_mime_header_get_value(h));
                
                header_array.append(item);
            }
            json_message[label] = header_array;
        }
        g_mime_header_list_clear(headers);
    }
    return hasHeaders;
}

static void getAddress(InternetAddressList *list, const char *label, Json::Value& json_message) {
    
    InternetAddress *address;
    
    if(list)
    {
        int len = internet_address_list_length(list);
        
        if(len)
        {
            Json::Value address_array = Json::Value(Json::arrayValue);
            
            for(int i = 0; i < len; ++i)
            {
                address = internet_address_list_get_address(list, i);
                
                Json::Value item = Json::Value(Json::objectValue);
                
                //internet_address_to_string will alloc
                // https://developer.gnome.org/gmime/stable/InternetAddress.html#internet-address-to-string
                
                char *string = internet_address_to_string(address, NULL, FALSE);
                item["string"] = string ? string : "";
                if(string) g_free(string);
                
                char *encoded_string = internet_address_to_string(address, NULL, TRUE);
                item["encoded_string"] = encoded_string ? encoded_string : "";
                if(encoded_string) g_free(encoded_string);
                
                const char *addr = internet_address_mailbox_get_addr((InternetAddressMailbox *)address);
                item["addr"] = addr ? addr : "";

                const char *idn_addr = internet_address_mailbox_get_idn_addr((InternetAddressMailbox *)address);
                item["idn_addr"] = idn_addr ? idn_addr : "";
                
                const char *name = internet_address_get_name(address);
                item["name"] = name ? name : "";
                
                address_array.append(item);
                
            }
            json_message[label] = address_array;

        }else
        {
            //create an empty array
            json_message[label] = Json::Value(Json::arrayValue);
        }
        internet_address_list_clear(list);
    }else
    {
        //create an empty array
        json_message[label] = Json::Value(Json::arrayValue);
    }
    
}

static bool isPartialTextPart(GMimeObject *part) {
    
    if(0 == strncasecmp(part->content_type->type, "message", 7)) {
        if(0 == strncasecmp(part->content_type->subtype, "partial", 7)) {
            return true;
        }
    }
    return false;
}

static void processBodyOrAttachment(GMimeObject *parent, GMimeObject *part, mime_ctx_simple *ctx);

static void addToBody(GMimeObject *parent, GMimeObject *part, mime_ctx_simple *ctx) {
    
    ctx->name =  "body";

    processBodyOrAttachment(parent, part, ctx);
}

static void addToPart(GMimeObject *parent, GMimeObject *part, mime_ctx_simple *ctx) {

    ctx->name =  "parts";

    processBodyOrAttachment(parent, part, ctx);
}

static void addToAttachment(GMimeObject *parent, GMimeObject *part, mime_ctx_simple *ctx) {
    
    ctx->name =  "attachments";

    processBodyOrAttachment(parent, part, ctx);
}

static void logMimeType(GMimeObject *part, const char *c, mime_ctx_simple *ctx) {
    
    GMimeContentType *partMediaType = g_mime_object_get_content_type(part);
    const char *mediaType = g_mime_content_type_get_media_type(partMediaType);
    const char *mediaSubType = g_mime_content_type_get_media_subtype(partMediaType);
    
    std::string level = "";
    
    for(int i = 1; ctx->level > i ; ++i) {
        level += c;
    }
    //NSLog(@"%s%s/%s", level.c_str(), mediaType, mediaSubType);
}

#pragma mark -

static void processAttachmentMessage(GMimeObject *parent, GMimeObject *part, mime_ctx_simple *ctx);

static void processMessage(GMimeObject *parent, GMimeObject *part, gpointer user_data);

static void processBottomLevel(GMimeObject *parent, GMimeObject *part, gpointer user_data);

static void processNextLevel(GMimeObject *parent, GMimeObject *part, gpointer user_data);

static void processPart(GMimeObject *parent, GMimeObject *part, gpointer user_data) {
    
    mime_ctx_simple *ctx = (mime_ctx_simple *)user_data;
        
    if(GMIME_IS_MESSAGE_PART(part))
    {
        GMimeMessage *message = g_mime_message_part_get_message ((GMimeMessagePart *)part);
                
        ctx->name =  "attachments";
 
        processAttachmentMessage(parent, part, ctx);
                
        if (message) {
            bool is_main_message = ctx->is_main_message;
            ctx->is_main_message = false;
            //logMimeType(part, "-", ctx);
            ctx->level++;
            g_mime_message_foreach(message, processMessage, ctx);
            ctx->level--;
            ctx->is_main_message = is_main_message;
        }
    }
}

static void processAttachmentMessage(GMimeObject *parent, GMimeObject *part, mime_ctx_simple *ctx) {
    if(GMIME_IS_MESSAGE_PART(part)) {
                
        Json::Value json_part = Json::Value(Json::objectValue);
        
        const char *_content_disposition = g_mime_content_disposition_get_disposition(g_mime_object_get_content_disposition (part));
        std::string content_disposition;
        if(_content_disposition != NULL) {
            content_disposition = _content_disposition;
        }
        const char *_content_description = g_mime_part_get_content_description((GMimePart *)part);
        std::string content_description;
        if(_content_description != NULL) {
            content_description = _content_description;
        }
        const char *_content_md5 = g_mime_part_get_content_md5((GMimePart *)part);
        std::string content_md5;
        if(_content_md5 != NULL) {
            content_md5 = _content_md5;
        }
        const char *_file_name = g_mime_part_get_filename((GMimePart *)part);
        std::string file_name;
        if(_file_name != NULL) {
            file_name = _file_name;
        }
        if(file_name.length() == 0) {
            _file_name = g_mime_object_get_content_type_parameter (part, "name");
            if(_file_name != NULL) {
                file_name = _file_name;
            }
        }
        if(file_name.length() == 0) {
            _file_name = g_mime_object_get_content_disposition_parameter (part, "filename");
            if(_file_name != NULL) {
                file_name = _file_name;
            }
        }
        const char *_content_encoding = g_mime_content_encoding_to_string(g_mime_part_get_content_encoding((GMimePart *)part));
        std::string content_encoding;
        if(_content_encoding != NULL) {
            content_encoding = _content_encoding;
        }
        else{
            _content_encoding = g_mime_object_get_header(part, "Content-Transfer-Encoding");
            if(_content_encoding != NULL) {
                content_encoding = _content_encoding;
            }
        }
        
        const char *_content_id = g_mime_object_get_content_id(part);
        std::string content_id;
        if(_content_id != NULL) {
            content_id = _content_id;
        }
        
        /*
         getHeaders() invalidates disposition
         */
        
        bool hasHeaders = getHeaders(part, "headers", json_part);

        if(hasHeaders) {
                        
            GMimeFormatOptions *format_options = g_mime_format_options_new();
            g_mime_format_options_set_param_encoding_method(format_options, GMIME_PARAM_ENCODING_METHOD_RFC2231);
            g_mime_format_options_set_newline_format (format_options, GMIME_NEWLINE_FORMAT_DOS);
            GMimeStream *stream = g_mime_stream_mem_new();
            GByteArray *array = g_byte_array_new();
            g_mime_stream_mem_set_byte_array ((GMimeStreamMem *)stream, array);
            g_mime_object_write_to_stream (part, format_options, stream);
            
            PA_long32 i = PA_GetArrayNbElements(*(ctx->array_blob));
            PA_ResizeArray(ctx->array_blob, ++i);
            
            PA_Variable element = PA_CreateVariable(eVK_Blob);
            
            guint8 *data = array->data;
            guint   len  = array->len;
            
            for (guint i = 0; i < array->len; ++i) {
                
                if(*data == '\r') {
                    data++;
                    len--;
                    continue;
                }
                
                if(*data == '\n') {
                    data++;
                    len--;
                    continue;
                }
                
                break;
            }
            
            
            //PA_SetBlobVariable(&element, array->data, array->len);
            PA_SetBlobVariable(&element, data, len);
            PA_SetBlobInArray(*(ctx->array_blob), i, element.uValue.fBlob);
            
                    json_part["data"] = i;

            //Content-Type
            GMimeContentType *type = g_mime_object_get_content_type(part);
            
            //g_mime_content_type_get_mime_type will alloc
            // https://developer.gnome.org/gmime/stable/GMimeContentType.html#g-mime-content-type-get-mime-type

                    char *mime_type = g_mime_content_type_get_mime_type(type);
                    json_part["mime_type"] = mime_type ? mime_type : "";
                    if(mime_type) g_free(mime_type);
                    
                    const char *media_type = g_mime_content_type_get_media_type(type);
                    json_part["media_type"] = media_type ? media_type : "";
                    
                    const char *media_subtype = g_mime_content_type_get_media_subtype(type);
                    json_part["media_subtype"] = media_subtype ? media_subtype : "";
                    
                    const char *content_id = g_mime_object_get_content_id(part);
                    if(content_id) {
                        json_part["content_id"] = content_id;
                    }
                    
            
            if(content_encoding.length() != 0) {
                json_part["content_encoding"] = content_encoding.c_str();
            }

            if(file_name.length() != 0) {
                json_part["file_name"] = file_name.c_str();
            }
                        
            if(content_description.length() != 0) {
                json_part["content_description"] = content_description.c_str();
            }

            if(content_md5.length() != 0) {
                json_part["content_md5"] = content_md5.c_str();
            }
            
            if(content_disposition.length() != 0) {
                json_part["content_disposition"] = content_disposition.c_str();
            }

                    Json::Value *value = ctx->json;
                    if(value->isObject())
                    {
                        Json::Value defaultValue;
                        Json::Value part = value->get(ctx->name, defaultValue);
                        
                        if(part.isArray())
                        {
                            (*value)[ctx->name].append(json_part);
                            
                        }else{
                            (*value)[ctx->name] = Json::Value(Json::arrayValue);
                            (*value)[ctx->name].append(json_part);
                        }
                        
                    }

            
            //cleanup
            g_object_unref (stream);//GMimeStream
            g_byte_array_free (array, FALSE);//GByteArray
            g_mime_format_options_free(format_options);//GMimeFormatOptions

        }else{         

        }
    }
}

static void processMessage(GMimeObject *parent, GMimeObject *part, gpointer user_data) {
    
    mime_ctx_simple *ctx = (mime_ctx_simple *)user_data;

    if(GMIME_IS_MULTIPART(part)) {
//       logMimeType(part, "+", ctx);
//       for each works from the bottom up!
        ctx->level++;
        g_mime_multipart_foreach((GMimeMultipart *)part, processPart, ctx);
        ctx->level--;
    }
    
    bool addedToBody = false;
    
    GMimeContentDisposition *disposition = g_mime_object_get_content_disposition (part);
    
    /*
      definition of a body: part is main message (not message/rfc822) and
      1. content-type is text/* and content-disposition is inline or
      2. content-type is text/* and content-disposition missing or
      3. content-type is message/partial
     */
    
    if    ((GMIME_IS_TEXT_PART(part) && (!disposition))
       || (isPartialTextPart(part))
       || ((GMIME_IS_TEXT_PART(part) && ( disposition) && (0 == strncasecmp(g_mime_content_disposition_get_disposition(disposition), "inline", 6)))))
    {
        if(ctx->is_main_message) {
//            logMimeType(part, "*", ctx);
            addToBody(parent, part, ctx);
            addedToBody = true;
        }
    }
    
    if((!addedToBody) && GMIME_IS_PART(part))
    {
//        logMimeType(part, "-", ctx);
        if(ctx->is_main_message) {
            addToAttachment(parent, part, ctx);
        }else{
            addToPart(parent, part, ctx);
        }
    }
    
}

static void processTopLevel(GMimeObject *parent, GMimeObject *part, gpointer user_data) {
    
    mime_ctx *ctx = (mime_ctx *)user_data;
    
    if(ctx->is_top_level) {
        ctx->is_top_level = false;
    }
    
    bool isPart = GMIME_IS_PART(part);
    bool isMessage = GMIME_IS_MESSAGE_PART(part);
    bool isMultipart = GMIME_IS_MULTIPART(part);
    
    if(ctx->is_message) {
        if(isPart) {
            ctx->part++;
        }
    }
    
    if(!isMultipart) {
        
        if(!isMessage) {
            
            if(isPart) {
                
                GMimeContentDisposition *disposition = g_mime_object_get_content_disposition (part);
                if(!disposition) {
                    
                    GMimeContentType *partMediaType = g_mime_object_get_content_type(part);
                    const char *mediaType = g_mime_content_type_get_media_type(partMediaType);
                    
                    if(0 == strncasecmp(mediaType, "text", 4))
                    {
                        ctx->name =  "body";
                        
                        processBottomLevel(parent, part, ctx);
                    }else{
                        
                        if(0 == strncasecmp(part->content_type->type, "message", 7)) {
                            if(0 == strncasecmp(part->content_type->subtype, "partial", 7)) {
                                ctx->name =  "body";
                                processBottomLevel(parent, part, ctx);
                            }
                        }else {
                            if(g_mime_part_get_content_encoding((GMimePart *)part)) {
                                ctx->name =  "attachments";
                                processBottomLevel(parent, part, ctx);
                            }else {
                                /* single part, not partical message, not body, not node */
                                if(!GMIME_IS_MULTIPART(parent)) {
                                    ctx->name =  "attachments";
                                    processBottomLevel(parent, part, ctx);
                                }
                            }
                        }
                    }
                }
            }
            
        }else{
            //is message
            GMimeMessage *message = g_mime_message_part_get_message ((GMimeMessagePart *)part);
            if (message) {
                
                ctx->is_message = true;
                
                GMimeMessage *_message = ctx->message;
                ctx->message = message;
                g_mime_message_foreach(message, processNextLevel, ctx);
                ctx->message = _message;
                
            }
            
        }
        
    }else{
        //not multipart (node)
        ctx->is_message = false;
        
        ctx->level++;
        g_mime_multipart_foreach((GMimeMultipart *)part, processNextLevel, ctx);
        ctx->level--;
        
    }
    
}

static void processNextLevel(GMimeObject *parent, GMimeObject *part, gpointer user_data) {
    
    mime_ctx *ctx = (mime_ctx *)user_data;
    
    bool isPart = GMIME_IS_PART(part);
    bool isMessage = GMIME_IS_MESSAGE_PART(part);
    bool isMultipart = GMIME_IS_MULTIPART(part);
    
    if(ctx->is_message) {
        if(isPart) {
            ctx->part++;
        }
    }
    
    if(!isMultipart) {
        
        if(!isMessage) {
            
            if(isPart) {
                
                GMimeContentDisposition *disposition = g_mime_object_get_content_disposition (part);
                if(disposition) {
                    if(g_mime_part_get_content_encoding((GMimePart *)part)) {
                        ctx->name =  "attachments";
                        processBottomLevel(parent, part, ctx);
                    }
                }else{
                    //no disposition;
                }
            }
        }else{
            GMimeMessage *message = g_mime_message_part_get_message ((GMimeMessagePart *)part);
            if (message) {
                
                ctx->is_message = true;
                
                GMimeMessage *_message = ctx->message;
                ctx->message = message;
                g_mime_message_foreach(message, processTopLevel, ctx);
                ctx->message = _message;
                
            }
        }
        
    }else{
        
        ctx->is_message = false;
        
        ctx->level++;
        g_mime_multipart_foreach((GMimeMultipart *)part, processNextLevel, ctx);
        ctx->level--;
        
    }
    
}

static void processBodyOrAttachment(GMimeObject *parent, GMimeObject *part, mime_ctx_simple *ctx) {
    
    //wrapper exists for part except message/rfc822
    GMimeDataWrapper *wrapper = g_mime_part_get_content((GMimePart *)part);
    
    if(wrapper)
    {
        Json::Value json_part = Json::Value(Json::objectValue);
        
        const char *_content_disposition = g_mime_content_disposition_get_disposition(g_mime_object_get_content_disposition (part));
        std::string content_disposition;
        if(_content_disposition != NULL) {
            content_disposition = _content_disposition;
        }
        const char *_content_description = g_mime_part_get_content_description((GMimePart *)part);
        std::string content_description;
        if(_content_description != NULL) {
            content_description = _content_description;
        }
        const char *_content_md5 = g_mime_part_get_content_md5((GMimePart *)part);
        std::string content_md5;
        if(_content_md5 != NULL) {
            content_md5 = _content_md5;
        }
        const char *_file_name = g_mime_part_get_filename((GMimePart *)part);
        std::string file_name;
        if(_file_name != NULL) {
            file_name = _file_name;
        }
        if(file_name.length() == 0) {
            _file_name = g_mime_object_get_content_type_parameter (part, "name");
            if(_file_name != NULL) {
                file_name = _file_name;
            }
        }
        if(file_name.length() == 0) {
            _file_name = g_mime_object_get_content_disposition_parameter (part, "filename");
            if(_file_name != NULL) {
                file_name = _file_name;
            }
        }
        const char *_content_encoding = g_mime_content_encoding_to_string(g_mime_part_get_content_encoding((GMimePart *)part));
        std::string content_encoding;
        if(_content_encoding != NULL) {
            content_encoding = _content_encoding;
        }
        else{
            _content_encoding = g_mime_object_get_header(part, "Content-Transfer-Encoding");
            if(_content_encoding != NULL) {
                content_encoding = _content_encoding;
            }
        }
        const char *_content_id = g_mime_object_get_content_id(part);
        std::string content_id;
        if(_content_id != NULL) {
            content_id = _content_id;
        }
        
        /*
         getHeaders() invalidates disposition
         */
        
        bool hasHeaders = getHeaders(part, "headers", json_part);
        
        if(hasHeaders) {
            if(GMIME_IS_MESSAGE_PART(part)) {
                
                GMimeMessage *message = ctx->message;
                
                getAddress(g_mime_message_get_from (message), "from", json_part);
                getAddress(g_mime_message_get_cc (message), "cc", json_part);
                getAddress(g_mime_message_get_to (message), "to", json_part);
                getAddress(g_mime_message_get_bcc (message), "bcc", json_part);
                getAddress(g_mime_message_get_sender (message), "sender", json_part);
                getAddress(g_mime_message_get_reply_to (message), "reply_to", json_part);
                getAddress(g_mime_message_get_all_recipients (message), "all_recipients", json_part);
                
                json_part["id"]      = g_mime_message_get_message_id(message);
                json_part["subject"] = g_mime_message_get_subject(message);
                
                GDateTime *date = g_mime_message_get_date(message);
                
                if(date)
                {
                    GDateTime *local_date_dt = g_date_time_to_local(date);
                    int local_time = ((g_date_time_get_hour(local_date_dt) * 3600)
                                      + (g_date_time_get_minute(local_date_dt) * 60)
                                      +  g_date_time_get_second(local_date_dt)) * 1000;
                    
                    gchar *local_date = g_date_time_format(local_date_dt, "%Y-%m-%dT%H:%M:%S%z");
                    
                    json_part["local_date"] = local_date;
                    json_part["local_time"] = local_time;
                    
#if VERSIONMAC
                    if(local_date)
                    {
                        g_free(local_date);//corrupts heap on windows
                    }
#endif
                    g_date_time_unref(local_date_dt);
                    
                    int utc_time = ((g_date_time_get_hour(date) * 3600)
                                    + (g_date_time_get_minute(date) * 60)
                                    +  g_date_time_get_second(date)) * 1000;
                    
                    gchar *utc_date = g_date_time_format(date, "%Y-%m-%dT%H:%M:%S%z");
                    
                    json_part["utc_date"] = utc_date;
                    json_part["utc_time"] = utc_time;
                    
#if VERSIONMAC
                    if(utc_date)
                    {
                        g_free(utc_date);//corrupts heap on windows
                    }
#endif
                    
                }else
                {
                    json_part["local_date"] = Json::Value(Json::nullValue);
                    json_part["local_time"] = Json::Value(Json::nullValue);
                    json_part["utc_date"]   = Json::Value(Json::nullValue);
                    json_part["utc_time"]   = Json::Value(Json::nullValue);
                }
            }
            
            bool isBinary = true;
            
            GMimeContentType *partMediaType = g_mime_object_get_content_type(part);
            const char *mediaType = g_mime_content_type_get_media_type(partMediaType);
            if(0 == strncasecmp(mediaType, "text", 4))
            {
                //g_mime_text_part_get_text will alloc
                // https://developer.gnome.org/gmime/stable/GMimeTextPart.html
                
                //special consideration for microsoft mht
                const char *charset = g_mime_text_part_get_charset((GMimeTextPart *)part);
                if(charset && (0 == strncasecmp(charset, "unicode", 7)))
                {
                    g_mime_text_part_set_charset ((GMimeTextPart *)part, "utf-16le");
                }
                
                if(charset) {
                    
                    char *text = g_mime_text_part_get_text((GMimeTextPart *)part);
                    json_part["data"] = text;
                    if(text) g_free(text);
                    
                    isBinary = false;
                }
                
            }
            
            if(isBinary) {
                
                GMimeStream *content = g_mime_stream_mem_new();
                g_mime_data_wrapper_write_to_stream(wrapper, content);
                GByteArray *bytes = g_mime_stream_mem_get_byte_array ((GMimeStreamMem *)content);
                
                PA_long32 i = PA_GetArrayNbElements(*(ctx->array_blob));
                PA_ResizeArray(ctx->array_blob, ++i);
                
                PA_Variable element = PA_CreateVariable(eVK_Blob);
                PA_SetBlobVariable(&element, (void *)bytes->data, bytes->len);
                PA_SetBlobInArray(*(ctx->array_blob), i, element.uValue.fBlob);
                json_part["data"] = i;
                
                g_mime_stream_close(content);
                g_clear_object(&content);
                
            }
            
            //Content-Type
            GMimeContentType *type = g_mime_object_get_content_type(part);
            
            //g_mime_content_type_get_mime_type will alloc
            // https://developer.gnome.org/gmime/stable/GMimeContentType.html#g-mime-content-type-get-mime-type
            
            char *mime_type = g_mime_content_type_get_mime_type(type);
            json_part["mime_type"] = mime_type ? mime_type : "";
            if(mime_type) g_free(mime_type);
            
            const char *media_type = g_mime_content_type_get_media_type(type);
            json_part["media_type"] = media_type ? media_type : "";
            
            const char *media_subtype = g_mime_content_type_get_media_subtype(type);
            json_part["media_subtype"] = media_subtype ? media_subtype : "";
            
            if(content_id.length() != 0) {
                json_part["content_id"] = content_id.c_str();
            }
            
            if(content_encoding.length() != 0) {
                json_part["content_encoding"] = content_encoding.c_str();
            }
            
            if(file_name.length() != 0) {
                json_part["file_name"] = file_name.c_str();
            }
            
            if(content_description.length() != 0) {
                json_part["content_description"] = content_description.c_str();
            }
            
            if(content_md5.length() != 0) {
                json_part["content_md5"] = content_md5.c_str();
            }
            
            if(content_disposition.length() != 0) {
                json_part["content_disposition"] = content_disposition.c_str();
            }
            
            Json::Value *value = ctx->json;
            if(value->isObject())
            {
                Json::Value defaultValue;
                Json::Value part = value->get(ctx->name, defaultValue);
                
                if(part.isArray())
                {
                    (*value)[ctx->name].append(json_part);
                    
                }else{
                    (*value)[ctx->name] = Json::Value(Json::arrayValue);
                    (*value)[ctx->name].append(json_part);
                }
                
            }
            
        }else{
            
        }
    }
}

static void processBottomLevel(GMimeObject *parent, GMimeObject *part, gpointer user_data) {
    
    mime_ctx *ctx = (mime_ctx *)user_data;
        
    GMimeDataWrapper *wrapper = g_mime_part_get_content((GMimePart *)part);
    if(wrapper)
    {
        Json::Value json_part = Json::Value(Json::objectValue);

        const char *_content_disposition = g_mime_content_disposition_get_disposition(g_mime_object_get_content_disposition (part));
        std::string content_disposition;
        if(_content_disposition != NULL) {
            content_disposition = _content_disposition;
        }
        const char *_content_description = g_mime_part_get_content_description((GMimePart *)part);
        std::string content_description;
        if(_content_description != NULL) {
            content_description = _content_description;
        }
        const char *_content_md5 = g_mime_part_get_content_md5((GMimePart *)part);
        std::string content_md5;
        if(_content_md5 != NULL) {
            content_md5 = _content_md5;
        }
        const char *_file_name = g_mime_part_get_filename((GMimePart *)part);
        std::string file_name;
        if(_file_name != NULL) {
            file_name = _file_name;
        }
        if(file_name.length() == 0) {
            _file_name = g_mime_object_get_content_type_parameter (part, "name");
            if(_file_name != NULL) {
                file_name = _file_name;
            }
        }
        if(file_name.length() == 0) {
            _file_name = g_mime_object_get_content_disposition_parameter (part, "filename");
            if(_file_name != NULL) {
                file_name = _file_name;
            }
        }
        const char *_content_encoding = g_mime_content_encoding_to_string(g_mime_part_get_content_encoding((GMimePart *)part));
        std::string content_encoding;
        if(_content_encoding != NULL) {
            content_encoding = _content_encoding;
        }
        else{
            _content_encoding = g_mime_object_get_header(part, "Content-Transfer-Encoding");
            if(_content_encoding != NULL) {
                content_encoding = _content_encoding;
            }
        }
        const char *_content_id = g_mime_object_get_content_id(part);
        std::string content_id;
        if(_content_id != NULL) {
            content_id = _content_id;
        }
        
        /*
         getHeaders() invalidates disposition
         */
        
        if(GMIME_IS_MESSAGE_PART(part)) {
            
            GMimeMessage *message = ctx->message;

            getAddress(g_mime_message_get_from (message), "from", json_part);
            getAddress(g_mime_message_get_cc (message), "cc", json_part);
            getAddress(g_mime_message_get_to (message), "to", json_part);
            getAddress(g_mime_message_get_bcc (message), "bcc", json_part);
            getAddress(g_mime_message_get_sender (message), "sender", json_part);
            getAddress(g_mime_message_get_reply_to (message), "reply_to", json_part);
            getAddress(g_mime_message_get_all_recipients (message), "all_recipients", json_part);
            
            json_part["id"]      = g_mime_message_get_message_id(message);
            json_part["subject"] = g_mime_message_get_subject(message);


            GDateTime *date = g_mime_message_get_date(message);
            
            if(date)
            {
                GDateTime *local_date_dt = g_date_time_to_local(date);
                int local_time = ((g_date_time_get_hour(local_date_dt) * 3600)
                                  + (g_date_time_get_minute(local_date_dt) * 60)
                                  +  g_date_time_get_second(local_date_dt)) * 1000;
                
                gchar *local_date = g_date_time_format(local_date_dt, "%Y-%m-%dT%H:%M:%S%z");
                
                json_part["local_date"] = local_date;
                json_part["local_time"] = local_time;
                
#if VERSIONMAC
                if(local_date)
                {
                    g_free(local_date);//corrupts heap on windows
                }
#endif
                g_date_time_unref(local_date_dt);
                    
                int utc_time = ((g_date_time_get_hour(date) * 3600)
                                + (g_date_time_get_minute(date) * 60)
                                +  g_date_time_get_second(date)) * 1000;
                
                gchar *utc_date = g_date_time_format(date, "%Y-%m-%dT%H:%M:%S%z");
                
                json_part["utc_date"] = utc_date;
                json_part["utc_time"] = utc_time;
                
#if VERSIONMAC
                if(utc_date)
                {
                    g_free(utc_date);//corrupts heap on windows
                }
#endif
            
            }else
            {
                json_part["local_date"] = Json::Value(Json::nullValue);
                json_part["local_time"] = Json::Value(Json::nullValue);
                json_part["utc_date"]   = Json::Value(Json::nullValue);
                json_part["utc_time"]   = Json::Value(Json::nullValue);
            }
        }
        
        bool isBinary = true;
        
        GMimeContentType *partMediaType = g_mime_object_get_content_type(part);
        const char *mediaType = g_mime_content_type_get_media_type(partMediaType);
        if(0 == strncasecmp(mediaType, "text", 4))
        {
            //g_mime_text_part_get_text will alloc
            // https://developer.gnome.org/gmime/stable/GMimeTextPart.html
            
            //special consideration for microsoft mht
            const char *charset = g_mime_text_part_get_charset((GMimeTextPart *)part);
            if(charset && (0 == strncasecmp(charset, "unicode", 7)))
            {
                g_mime_text_part_set_charset ((GMimeTextPart *)part, "utf-16le");
            }
            
            if(charset) {

                char *text = g_mime_text_part_get_text((GMimeTextPart *)part);
                json_part["data"] = text;
                if(text) g_free(text);

                isBinary = false;
            }
 
        }
        
        if(isBinary) {
            
            GMimeStream *content = g_mime_stream_mem_new();
            g_mime_data_wrapper_write_to_stream(wrapper, content);
            GByteArray *bytes = g_mime_stream_mem_get_byte_array ((GMimeStreamMem *)content);
            
            PA_long32 i = PA_GetArrayNbElements(*(ctx->array_blob));
            PA_ResizeArray(ctx->array_blob, ++i);
            
            PA_Variable element = PA_CreateVariable(eVK_Blob);
            PA_SetBlobVariable(&element, (void *)bytes->data, bytes->len);
            PA_SetBlobInArray(*(ctx->array_blob), i, element.uValue.fBlob);

            json_part["data"] = i;

            g_mime_stream_close(content);
            g_clear_object(&content);
            
        }

        json_part["level"]   = ctx->part_level;
        json_part["message"] = ctx->part;

        //Content-Type
        GMimeContentType *type = g_mime_object_get_content_type(part);
        
        //g_mime_content_type_get_mime_type will alloc
        // https://developer.gnome.org/gmime/stable/GMimeContentType.html#g-mime-content-type-get-mime-type
        
        char *mime_type = g_mime_content_type_get_mime_type(type);
        json_part["mime_type"] = mime_type ? mime_type : "";
        if(mime_type) g_free(mime_type);

        const char *media_type = g_mime_content_type_get_media_type(type);
        json_part["media_type"] = media_type ? media_type : "";
        
        const char *media_subtype = g_mime_content_type_get_media_subtype(type);
        json_part["media_subtype"] = media_subtype ? media_subtype : "";
        
        if(content_id.length() != 0) {
            json_part["content_id"] = content_id.c_str();
        }
        
        if(content_encoding.length() != 0) {
            json_part["content_encoding"] = content_encoding.c_str();
        }
        
        if(file_name.length() != 0) {
            json_part["file_name"] = file_name.c_str();
        }
        
        if(content_description.length() != 0) {
            json_part["content_description"] = content_description.c_str();
        }
        
        if(content_md5.length() != 0) {
            json_part["content_md5"] = content_md5.c_str();
        }
        
        if(content_disposition.length() != 0) {
            json_part["content_disposition"] = content_disposition.c_str();
        }

        getHeaders(part, "headers", json_part);

        Json::Value *value = ctx->json;
        if(value->isObject())
        {
            Json::Value defaultValue;
            Json::Value part = value->get(ctx->name, defaultValue);
            
            if(part.isArray())
            {
                (*value)[ctx->name].append(json_part);
                
            }else{
                (*value)[ctx->name] = Json::Value(Json::arrayValue);
                (*value)[ctx->name].append(json_part);
            }

        }
    }
}

static void add_mailboxes(GMimeMessage *message, Json::Value& message_node, const char *key, GMimeAddressType type) {
    
    Json::Value node = message_node[key];
    
    if(node.isArray())
    {
        for(Json::Value::const_iterator it = node.begin() ; it != node.end() ; it++)
        {
            if(it->isObject())
            {
                Json::Value defaultValue = "";
                
                Json::Value name = it->get("name", defaultValue);
                Json::Value addr = it->get("addr", defaultValue);

                JSONCPP_STRING name_s, addr_s;
                
                name_s = name.isString() ? name.asString() : "";
                addr_s = addr.isString() ? addr.asString() : "";

                g_mime_message_add_mailbox(message, type, name_s.c_str(), addr_s.c_str());
            }
        }
    }
}

static void add_headers(GMimeObject *message_mime, Json::Value& message_node) {
    
    Json::Value node = message_node["headers"];
    
    if(node.isArray())
    {
        for(Json::Value::const_iterator it = node.begin() ; it != node.end() ; it++)
        {
            if(it->isObject())
            {
                Json::Value defaultValue = "";
                
                Json::Value name    = it->get("name"   , defaultValue);
                Json::Value value   = it->get("value"  , defaultValue);
                Json::Value charset = it->get("charset", defaultValue);
                                
                JSONCPP_STRING name_s, value_s, charset_s;
                
                name_s    = name.isString() ?    name.asString() : "";
                value_s   = name.isString() ?   value.asString() : "";
                charset_s = name.isString() ? charset.asString() : NULL;

                if (name_s.length()) {
                    if (value_s.length()) {
                        //g_mime_object_remove_header(message_mime, name_s.c_str());

						if (   (name_s != "from")
							&& (name_s != "cc")
							&& (name_s != "to")
							&& (name_s != "bcc")
							&& (name_s != "sender")
							&& (name_s != "reply_to")
							&& (name_s != "subject")) {
							g_mime_object_set_header(message_mime,
								name_s.c_str(),
								value_s.c_str(),
								charset_s.c_str());
						}  
                    }
                }
            }
        }
    }
}

static void add_date(GMimeMessage *message, Json::Value& message_node) {
    
    GMimeObject *message_mime = (GMimeObject *)message;
    
    Json::Value utc_date = message_node["utc_date"];
    
    if(utc_date.isString())
    {
        JSONCPP_STRING utc_date_s = utc_date.asString();

        GTimeVal time;
        if(g_time_val_from_iso8601 ((const gchar *)utc_date_s.c_str(), &time))
        {
            g_mime_object_remove_header(message_mime, "Date");
            GDateTime *date = g_date_time_new_from_timeval_utc(&time);
            g_mime_message_set_date(message, date);
            g_date_time_unref(date);
        }
    }else
    {
        Json::Value local_date = message_node["local_date"];
        
        if(local_date.isString())
        {
            GTimeVal time;
            if(g_time_val_from_iso8601 ((const gchar *)local_date.asString().c_str(), &time))
            {
                g_mime_object_remove_header(message_mime, "Date");
                GDateTime *date = g_date_time_new_from_timeval_local(&time);
                g_mime_message_set_date(message, date);
                g_date_time_unref(date);
            }
        }
    }
}

static void g_mime_text_part_set_text_with_charset(GMimeTextPart *mime_part, const char *text, const char *charset) {
    
    GMimeContentType *content_type;
    GMimeStream *filtered, *stream;
    GMimeContentEncoding encoding;
    GMimeDataWrapper *content;
    GMimeFilter *filter;
//    const char *charset;
    GMimeCharset mask;
    size_t len;
    
    g_return_if_fail (GMIME_IS_TEXT_PART (mime_part));
    g_return_if_fail (text != NULL);
    
    len = strlen (text);
    
    g_mime_charset_init (&mask);
    g_mime_charset_step (&mask, text, len);
    
    charset = "utf-8";
    
//    switch (mask.level) {
//    case 1: charset = "iso-8859-1"; break;
//    case 0: charset = "us-ascii"; break;
//    default: charset = "utf-8"; break;
//    }
    
    content_type = g_mime_object_get_content_type ((GMimeObject *) mime_part);
    g_mime_content_type_set_parameter (content_type, "charset", charset);
    
    stream = g_mime_stream_mem_new_with_buffer (text, len);
    
    if (mask.level == 1) {
        filtered = g_mime_stream_filter_new (stream);
        g_object_unref (stream);
        
        filter = g_mime_filter_charset_new ("utf-8", charset);
        g_mime_stream_filter_add ((GMimeStreamFilter *) filtered, filter);
        g_object_unref (filter);
        
        stream = filtered;
    }
    
    content = g_mime_data_wrapper_new_with_stream (stream, GMIME_CONTENT_ENCODING_DEFAULT);
    g_object_unref (stream);
    
    g_mime_part_set_content ((GMimePart *) mime_part, content);
    g_object_unref (content);
    
    encoding = g_mime_part_get_content_encoding ((GMimePart *) mime_part);
    
    /* if the user has already specified encoding the content with base64/qp/uu, don't change it */
    if (encoding > GMIME_CONTENT_ENCODING_BINARY)
        return;
    
    /* ...otherwise, set an appropriate Content-Transfer-Encoding based on the text provided... */
    if (mask.level > 0)
        g_mime_part_set_content_encoding ((GMimePart *) mime_part, GMIME_CONTENT_ENCODING_8BIT);
    else
        g_mime_part_set_content_encoding ((GMimePart *) mime_part, GMIME_CONTENT_ENCODING_7BIT);

}

static void add_parts(GMimeObject *message_mime,
                      Json::Value& message_node,
                      PA_Variable *data_array,
                      bool isBody,
                      GMimeMultipart **multipart,
                      Json::ArrayIndex *body_count,
                      Json::ArrayIndex *part_count,
                      std::string &boundary_a,
                      std::string &boundary_b)
       {
           GMimeMultipart *multipartForBody = NULL;
           GMimeMultipart *multipartForAttachment = NULL;
           
           /* remove default header */
           g_mime_object_remove_header (message_mime, "Content-Type");
           
           Json::Value node;
           
           if(isBody)
           {
               node = message_node["body"];
           }else
           {
               node = message_node["attachments"];
           }

           if(node.isArray())
           {
               Json::ArrayIndex array_size = node.size();
               /* need to know the number of body text */
               
               for(Json::Value::const_iterator it = node.begin() ; it != node.end() ; it++)
               {
                   if(it->isObject())
                   {
                       Json::Value defaultValue;

                       *part_count = (*part_count) + 1;
                       
                       if(isBody)
                       {
                           Json::Value part_content_type = it->get("mime_type", defaultValue);
                           
                           if(part_content_type.isString())
                           {
                               GMimeContentType *content_type = g_mime_content_type_parse(g_mime_parser_options_get_default(),
                                                                                          part_content_type.asString().c_str());
                               const char *mt = g_mime_content_type_get_media_type(content_type);
                               
                               if(0 == strncasecmp(mt, "text", 4))
                               {
                                   *body_count = (*body_count) + 1;
                                   
                                   if(*body_count == 2)
                                   {
                                       multipartForBody = g_mime_multipart_new();
                                       boundary_a = g_mime_multipart_get_boundary (multipartForBody);
                                       g_mime_message_set_mime_part((GMimeMessage *)message_mime, (GMimeObject *)multipartForBody);
                                       g_mime_object_set_content_type((GMimeObject *)multipartForBody,
                                                                      g_mime_content_type_parse(g_mime_parser_options_get_default(),
                                                                                                (const char *)"multipart/alternative"));
                                       g_mime_multipart_set_boundary (multipartForBody, boundary_a.c_str());
                                       if(*multipart)
                                       {
                                           /* multipart/related > multipart/alternative */
                                           g_mime_multipart_add (*multipart, (GMimeObject *)multipartForBody);
                                       }
                                   }
                               }else
                               {
                                   /* non-text body; inline images */
                                   if(*part_count > 1)
                                   {
                                       if(*multipart == NULL)
                                       {
                                           *multipart = g_mime_multipart_new();
                                           boundary_b = g_mime_multipart_get_boundary (*multipart);
                                           g_mime_message_set_mime_part((GMimeMessage *)message_mime, (GMimeObject *)*multipart);
                                           g_mime_object_set_content_type((GMimeObject *)*multipart,
                                                                          g_mime_content_type_parse(g_mime_parser_options_get_default(),
                                                                                                    (const char *)"multipart/related"));
                                           /* inline image for body */
                                           g_mime_multipart_set_boundary (multipartForBody, boundary_b.c_str());
                                       }
                                       if(multipartForBody)
                                       {
                                           /* multipart/related > multipart/alternative */
                                           g_mime_multipart_add (*multipart, (GMimeObject *)multipartForBody);
                                       }
                                   }
                               }
                           }
                       }else
                       {
                           if(*part_count > 1)
                           {
                               if(boundary_b.length())
                               {
                                   multipartForAttachment = *multipart;
                               }
                               
                               if(multipartForAttachment == NULL)
                               {
                                   /* there are not parts yet */
                                   multipartForAttachment = g_mime_multipart_new();
                                   boundary_b = g_mime_multipart_get_boundary (multipartForAttachment);
                                   /* the single part body */
                                   //                                    do this during the body run
                                   //                                    GMimePart *part = (GMimePart *)g_mime_message_get_body((GMimeMessage *)message_mime);
                                   
                                   g_mime_message_set_mime_part((GMimeMessage *)message_mime, (GMimeObject *)multipartForAttachment);
                                   g_mime_object_set_content_type((GMimeObject *)multipartForAttachment,
                                                                  g_mime_content_type_parse(g_mime_parser_options_get_default(),
                                                                                            (const char *)"multipart/mixed"));
                                   /* unrelated attachments */
                                   g_mime_multipart_set_boundary (multipartForAttachment, boundary_b.c_str());
                                   
                                   if(*multipart)
                                   {
                                       multipartForBody = *multipart;
                                       g_mime_multipart_add (multipartForAttachment, (GMimeObject *)multipartForBody);
                                   }
                                   
                                   *multipart = multipartForAttachment;
                                   //                                    do this during the body run
                                   //                                    g_mime_multipart_add (*multipart, (GMimeObject *)part);
                               }
                           }
                       }
                       
                   }
               }

               for(Json::Value::const_iterator it = node.begin() ; it != node.end() ; it++)
               {
                   if(it->isObject())
                   {
                       Json::Value defaultValue;
                       Json::Value data_node = it->get("data", defaultValue);
                       
                       if(isBody)
                       {
                           Json::Value part_content_type = it->get("mime_type", defaultValue);
                           
                           if(part_content_type.isString())
                           {
                               GMimeContentType *content_type = g_mime_content_type_parse(g_mime_parser_options_get_default(),
                                                                                          part_content_type.asString().c_str());
                               const char *mt = g_mime_content_type_get_media_type(content_type);
                               if(0 == strncasecmp(mt, "text", 4))
                               {
                                   if(multipartForBody)
                                   {
                                       *multipart = multipartForBody;
                                   }
                               }
                           }
                       }
                       
                       GMimePart *part = NULL;
                       GMimeTextPart *text_part = NULL;
                       
                       if(data_node.isString())
                       {
                           text_part = g_mime_text_part_new();
                           
                           JSONCPP_STRING part_charset("utf-8");
                           
                           Json::Value defaultValue;
                           Json::Value charset = it->get("charset", defaultValue);

                           if(charset.isString()) {
                               part_charset = charset.asString();
                           }
                           
                           /*
                            https://github.com/GNOME/gmime/blob/f1123691ba3110f3c945a3c6cf1a5128d6ab7dc3/gmime/gmime-text-part.c
                            */
                           
                           g_mime_text_part_set_text_with_charset(text_part,
                                                                  data_node.asString().c_str(),
                                                                  part_charset.c_str());
                           
                           //                                g_mime_text_part_set_text (text_part, (const char *)part_text.c_str());

                           part = (GMimePart *)text_part;
                           
                       }else{
                           
                           part = g_mime_part_new();
                           
                       }
                       
                       GMimeObject *part_mime = (GMimeObject *)part;
                       
                       Json::Value item_node = *it;
                       add_headers(part_mime, item_node);
                       
                       //base64 seems more robust for binary parts
                       if(data_node.isNumeric())
                       {
                           g_mime_part_set_content_encoding(part, GMIME_CONTENT_ENCODING_BASE64);
                       }else
                       {
                           Json::Value defaultValue;
                           Json::Value part_content_encoding = it->get("content_encoding", defaultValue);
                           
                           if(part_content_encoding.isString())
                           {
                               GMimeContentEncoding content_encoding = g_mime_content_encoding_from_string(part_content_encoding.asString().c_str());
                               g_mime_part_set_content_encoding(part, content_encoding);
                           }else
                           {
                               //make this the default for text
                               g_mime_part_set_content_encoding(part, GMIME_CONTENT_ENCODING_BASE64);
                           }
                       }
                                              
                       Json::Value part_content_id = it->get("content_id", defaultValue);
                                       
                       if(part_content_id.isString())
                           g_mime_part_set_content_id(part, part_content_id.asString().c_str());
                       
                       Json::Value part_content_type = it->get("mime_type", defaultValue);
                       
                       if(part_content_type.isString())
                       {
                           GMimeContentType *content_type = g_mime_content_type_parse(g_mime_parser_options_get_default(),
                                                                                      part_content_type.asString().c_str());
                           g_mime_object_set_content_type(part_mime, content_type);
                       }
                       
                       Json::Value part_content_location = it->get("content_location", defaultValue);
                       
                       if(part_content_location.isString())
                       {
                           g_mime_part_set_content_location(part, part_content_location.asString().c_str());
                       }
                       
                       Json::Value part_content_description = it->get("content_description", defaultValue);
                       
                       if(part_content_description.isString())
                       {
                           g_mime_part_set_content_description(part, part_content_description.asString().c_str());
                       }
                       
                       Json::Value part_file_name = it->get("file_name", defaultValue);
                       
                       if(part_file_name.isString())
                       {
                           g_mime_part_set_filename(part, part_file_name.asString().c_str());
                       }
                       
                       Json::Value part_content_md5 = it->get("content_md5", defaultValue);
                       
                       if(part_content_md5.isString())
                       {
                           g_mime_part_set_content_md5(part, part_content_md5.asString().c_str());
                       }
                       
                       if(isBody)
                       {
                           /* remove default header */
                           g_mime_object_remove_header (part_mime, "Content-Disposition");
                       }
                       
                       if(data_node.isNumeric())
                       {
                           Json::ArrayIndex data_index = data_node.asInt();
                           
                           if(PA_GetVariableKind(*data_array) == eVK_ArrayBlob)
                           {
                               if(PA_GetArrayNbElements(*data_array) >= data_index)
                               {
                                   PA_Blob data = PA_GetBlobInArray(*data_array, (PA_long32)data_index);
                                   void *data_buf = (void *)PA_LockHandle(data.fHandle);
                                   
                                   GMimeStream *stream = g_mime_stream_mem_new_with_buffer((const char *)data_buf, data.fSize);
                                   GMimeDataWrapper *wrapper = g_mime_data_wrapper_new_with_stream(stream, GMIME_CONTENT_ENCODING_DEFAULT);
                                   g_mime_part_set_content(part, wrapper);
                                   
                                   PA_UnlockHandle(data.fHandle);
                                   g_object_unref(wrapper);//GMimeDataWrapper
                                   g_object_unref(stream);//GMimeStream
                               }
                           }
                       }
                       
                       if(*multipart == NULL)
                       {
                           if(isBody)
                           {
                               bool isMultiPart = false;
                               
                               Json::Value node = message_node["attachments"];

                               if(node.isArray())
                               {
                                   
                                   Json::ArrayIndex array_size = node.size();
                                   if((array_size) != 0)
                                   {
                                       isMultiPart = true;
                                   }
                                   
                               }
                               if(isMultiPart)
                               {
                                   /* there are not parts yet */
                                   multipartForAttachment = g_mime_multipart_new();
                                   boundary_b = g_mime_multipart_get_boundary (multipartForAttachment);
                                   g_mime_message_set_mime_part((GMimeMessage *)message_mime, (GMimeObject *)multipartForAttachment);
                                   g_mime_object_set_content_type((GMimeObject *)multipartForAttachment,
                                                                  g_mime_content_type_parse(g_mime_parser_options_get_default(),
                                                                                            (const char *)"multipart/mixed"));
                                   /* unrelated attachments */
                                   g_mime_multipart_set_boundary (multipartForAttachment, boundary_b.c_str());
                                   *multipart = multipartForAttachment;
                                   g_mime_multipart_add (*multipart, (GMimeObject *)part_mime);
                               }else
                               {
                                   g_mime_message_set_mime_part ((GMimeMessage *)message_mime, part_mime);
                               }
                           }
                       }
                       else
                       {
                           g_mime_multipart_add (*multipart, part_mime);
                       }
                       
                       g_object_unref (part_mime);
                       
                   }
               }
           }
       }

static void convertFromString(std::string &fromString, CUTF16String &toString) {
    
#ifdef _WIN32
    int len = MultiByteToWideChar(CP_UTF8, 0, (LPCSTR)fromString.c_str(), fromString.length(), NULL, 0);
    
    if(len){
        std::vector<uint8_t> buf((len + 1) * sizeof(PA_Unichar));
        if(MultiByteToWideChar(CP_UTF8, 0, (LPCSTR)fromString.c_str(), fromString.length(), (LPWSTR)&buf[0], len)){
            toString = CUTF16String((const PA_Unichar *)&buf[0]);
        }
    }else{
        toString = CUTF16String((const PA_Unichar *)L"\0\0");
    }
#else
    CFStringRef str = CFStringCreateWithBytes(kCFAllocatorDefault, (const UInt8 *)fromString.c_str(), fromString.length(), kCFStringEncodingUTF8, true);
    if(str){
        int len = CFStringGetLength(str);
        std::vector<uint8_t> buf((len+1) * sizeof(PA_Unichar));
        CFStringGetCharacters(str, CFRangeMake(0, len), (UniChar *)&buf[0]);
        toString = CUTF16String((const PA_Unichar *)&buf[0]);
        CFRelease(str);
    }
#endif
}

#pragma mark -

#pragma mark Startup / Exit

void OnExit()
{
    g_mime_shutdown();
}

#if VERSIONWIN
BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)
{
    glib_DllMain(hinstDLL, fdwReason, lpvReserved);
    gio_DllMain(hinstDLL, fdwReason, lpvReserved);
    gobject_DllMain(hinstDLL, fdwReason, lpvReserved);

    return TRUE;
}
#endif

void OnStartup()
{
    g_mime_init();
}

#pragma mark -

void PluginMain(PA_long32 selector, PA_PluginParameters params) {
    
	try
	{
        switch(selector)
        {
            case kInitPlugin :
            case kServerInitPlugin :
                PA_RunInMainProcess((PA_RunInMainProcessProcPtr)OnStartup, NULL);
                break;

            case kDeinitPlugin :
            case kServerDeinitPlugin :
                PA_RunInMainProcess((PA_RunInMainProcessProcPtr)OnExit, NULL);
            break;
                
			// --- MIME
            
			case 1 :
				MIME_PARSE_MESSAGE(params);
				break;
			case 2 :
				MIME_Create_message(params);
				break;

        }

	}
	catch(...)
	{

	}
}

#pragma mark -

void MIME_PARSE_MESSAGE(PA_PluginParameters params)
{
    PackagePtr pParams = (PackagePtr)params->fParameters;
    
    C_TEXT Param2;
    
    PA_Variable Param3 = PA_CreateVariable(eVK_ArrayBlob);
    
    PA_Handle h = *(PA_Handle *)(pParams[0]);
    
    if(h)
    {
        Json::Value json = Json::Value(Json::objectValue);
        Json::Value json_message = Json::Value(Json::objectValue);

        GMimeStream *stream = g_mime_stream_mem_new_with_buffer((const char *)PA_LockHandle(h), PA_GetHandleSize(h));
        GMimeParser *parser = g_mime_parser_new_with_stream (stream);
        GMimeParserOptions *options = g_mime_parser_options_new();
        g_mime_parser_options_set_address_compliance_mode(options, GMIME_RFC_COMPLIANCE_LOOSE);
        g_mime_parser_options_set_allow_addresses_without_domain(options, true);
        g_mime_parser_options_set_parameter_compliance_mode(options, GMIME_RFC_COMPLIANCE_LOOSE);
        g_mime_parser_options_set_rfc2047_compliance_mode(options, GMIME_RFC_COMPLIANCE_LOOSE);
        GMimeMessage *message = g_mime_parser_construct_message (parser, options);
        g_mime_parser_options_free(options);
        g_clear_object(&parser);
        g_clear_object(&stream);
        
//        mime_ctx ctx;
        mime_ctx_simple ctx;
        
        ctx.json = &json_message;
        ctx.array_blob = &Param3;

        ctx.name =  "body";

//        ctx.is_top_level = true;
//        ctx.message = NULL;
        ctx.level = 1;
//        ctx.part_level = 1;
//        ctx.part = 1;
//        ctx.is_message = true;
        
        ctx.is_main_message = true;
        
        if(message)
        {
            ctx.message = message;

            getAddress(g_mime_message_get_from (message), "from", json_message);
            getAddress(g_mime_message_get_cc (message), "cc", json_message);
            getAddress(g_mime_message_get_to (message), "to", json_message);
            getAddress(g_mime_message_get_bcc (message), "bcc", json_message);
            getAddress(g_mime_message_get_sender (message), "sender", json_message);
            getAddress(g_mime_message_get_reply_to (message), "reply_to", json_message);
            getAddress(g_mime_message_get_all_recipients (message), "all_recipients", json_message);

            const char *message_id = g_mime_message_get_message_id(message);
            if(message_id)
                json_message["id"] = message_id;
            
            const char *message_subject = g_mime_message_get_subject(message);
            if(message_subject)
                json_message["subject"] = message_subject;

            GDateTime *date = g_mime_message_get_date(message);
            
            if(date)
            {

                GDateTime *local_date_dt = g_date_time_to_local(date);
                int local_time = ((g_date_time_get_hour(local_date_dt) * 3600)
                                  + (g_date_time_get_minute(local_date_dt) * 60)
                                  +  g_date_time_get_second(local_date_dt)) * 1000;
                
                gchar *local_date = g_date_time_format(local_date_dt, "%Y-%m-%dT%H:%M:%S%z");
                
                json_message["local_date"] = local_date;
                json_message["local_time"] = local_time;
                
#if VERSIONMAC
                if(local_date)
                {
                    g_free(local_date);//corrupts heap on windows
                }
#endif
                g_date_time_unref(local_date_dt);

                int utc_time = ((g_date_time_get_hour(date) * 3600)
                                + (g_date_time_get_minute(date) * 60)
                                +  g_date_time_get_second(date)) * 1000;
                
                gchar *utc_date = g_date_time_format(date, "%Y-%m-%dT%H:%M:%S%z");
                
                json_message["utc_date"] = utc_date;
                json_message["utc_time"] = utc_time;
                
#if VERSIONMAC
                if(utc_date)
                {
                    g_free(utc_date);//corrupts heap on windows
                }
#endif

            }else
            {
                /* g_mime_message_get_date returns NULL if the date could not be parsed */

                json_message["local_date"] = Json::Value(Json::nullValue);
                json_message["local_time"] = Json::Value(Json::nullValue);
                json_message["utc_date"] = Json::Value(Json::nullValue);
                json_message["utc_time"] = Json::Value(Json::nullValue);

            }
            getHeaders((GMimeObject *)message, "headers", json_message);
            
            g_mime_message_foreach(message, processMessage, &ctx);
            
            g_clear_object(&message);
        }

        json["message"] = json_message;

        CUTF16String u16;

        Json::StyledWriter writer;
        std::string returnValue = writer.write(json);
        convertFromString(returnValue, u16);

        Param2.setUTF16String(&u16);
        
        PA_UnlockHandle(h);
    }
    
    PA_SetVariableParameter(params, 3, Param3, 0);
    
    Param2.toParamAtIndex(pParams, 2);
}

void MIME_Create_message(PA_PluginParameters params)
{
        
    PackagePtr pParams = (PackagePtr)params->fParameters;
    
    C_TEXT Param1;
    Param1.fromParamAtIndex(pParams, 1);
    
    PA_Variable *data_array_p = ((PA_Variable *)pParams[1]);//Param2
        
    CUTF8String Param1_u8;
    Param1.copyUTF8String(&Param1_u8);
    
    Json::Value root;
    Json::CharReaderBuilder builder;
    std::string errors;
    
    Json::CharReader *reader = builder.newCharReader();
    bool parse = reader->parse((const char *)Param1_u8.c_str(),
                               (const char *)Param1_u8.c_str() + Param1_u8.size(),
                               &root,
                               &errors);
    delete reader;
    
    if(parse)
    {
        if(root.isObject())
        {
            GMimeMessage *message = g_mime_message_new(false);
            GMimeObject *message_mime = (GMimeObject *)message;
            
            Json::Value message_node = root["message"];
            
            if(message_node.isObject())
            {
                add_mailboxes(message, message_node, "from", GMIME_ADDRESS_TYPE_FROM);
                add_mailboxes(message, message_node, "cc", GMIME_ADDRESS_TYPE_CC);
                add_mailboxes(message, message_node, "to", GMIME_ADDRESS_TYPE_TO);
                add_mailboxes(message, message_node, "bcc", GMIME_ADDRESS_TYPE_BCC);
                add_mailboxes(message, message_node, "sender", GMIME_ADDRESS_TYPE_SENDER);
                add_mailboxes(message, message_node, "reply_to", GMIME_ADDRESS_TYPE_REPLY_TO);
                
                Json::Value subject_charset = message_node["subject_charset"];
                Json::Value subject = message_node["subject"];
                
                if(subject_charset.isString())
                {
                    g_mime_message_set_subject(message, subject.asString().c_str(),
                                               subject_charset.asString().c_str());//Subject with capital S
                    
                }else{
                    g_mime_message_set_subject(message, subject.asString().c_str(), NULL);
                }

                Json::Value message_id = message_node["id"];
                if(message_id.isString())
                {
                    g_mime_message_set_message_id(message, message_id.asString().c_str());
                }
 
                //over ride header definition
                Json::Value message_content_type = message_node["mime_type"];
                if(message_content_type.isString())
                {
                    GMimeContentType *content_type = g_mime_content_type_parse(g_mime_parser_options_get_default(),
                                                                               message_content_type.asString().c_str());
                    g_mime_object_set_content_type(message_mime, content_type);
                }
                
                add_headers(message_mime, message_node);
                add_date(message, message_node);
                
                GMimeMultipart *multipart = NULL;

                Json::ArrayIndex part_count = 0;
                Json::ArrayIndex body_count = 0;

                std::string boundary_a, boundary_b;
                
                add_parts(message_mime, message_node, data_array_p, true, &multipart, &body_count, &part_count, boundary_a, boundary_b);
                
                add_parts(message_mime, message_node, data_array_p, false, &multipart, &body_count, &part_count, boundary_a, boundary_b);
                
                //prepare
                GMimeFormatOptions *format_options = g_mime_format_options_new();
                
                g_mime_format_options_set_param_encoding_method(
                                                                format_options,
                                                                GMIME_PARAM_ENCODING_METHOD_RFC2231);

                g_mime_format_options_set_newline_format (
                                                          format_options,
                                                          GMIME_NEWLINE_FORMAT_DOS);
                
                GMimeStream *stream = g_mime_stream_mem_new();
                GByteArray *array = g_byte_array_new();
                g_mime_stream_mem_set_byte_array ((GMimeStreamMem *)stream, array);
                
                if(/* DISABLES CODE */ (0))
                {//debug: print headers
                    g_mime_header_list_write_to_stream(message_mime->headers, format_options, stream);
                }
                
                g_mime_object_write_to_stream (message_mime, format_options, stream);
                
                PA_ReturnBlob(params, array->data, array->len);
                
                //cleanup
                g_object_unref (stream);//GMimeStream
                g_byte_array_free (array, FALSE);//GByteArray
                g_mime_format_options_free(format_options);//GMimeFormatOptions
            }
        }
    }
}
